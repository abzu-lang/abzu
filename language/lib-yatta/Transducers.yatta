module Transducers exports filter, map, drop as

# pred: function of one argument (element) returning boolean value
# init: initial state
# step: function of two arguments (accumulator, element) returning new value of the accumulator
# complete: function of one argument (final state of accumulator) returning final return value
filter pred (init, step, complete) = let
  new_step = \acc val -> if pred val then step acc val else acc
in
  (\-> init, new_step, complete)

# pred: function of one argument (element)
# init: initial state
# step: function of two arguments (accumulator, element) returning new value of the accumulator
# complete: function of one argument (final state of accumulator) returning final return value
map fun (init, step, complete) = let
  new_step = \acc val -> step acc (fun val)
in
  (\ -> init, new_step, complete)

# n: number of elements to drop
# init: initial state
# step: function of two arguments (accumulator, element) returning new value of the accumulator
# complete: function of one argument (final state of accumulator) returning final return value
drop n (init, step, complete)
  | n > 0 = let
    new_step     = \(i, acc) val -> if i != 0 then (i - 1, acc) else (0, step acc val)
    new_complete = \(0, acc) -> complete acc
  in
    (\-> (n, init), new_step, new_complete)
