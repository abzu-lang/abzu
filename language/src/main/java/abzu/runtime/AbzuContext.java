package abzu.runtime;

import abzu.AbzuLanguage;
import abzu.ast.AbzuExpressionNode;
import abzu.ast.AbzuRootNode;
import abzu.ast.builtin.AbzuBuiltinNode;
import abzu.ast.local.AbzuReadArgumentNode;
import com.oracle.truffle.api.*;
import com.oracle.truffle.api.dsl.NodeFactory;
import com.oracle.truffle.api.frame.FrameDescriptor;
import com.oracle.truffle.api.instrumentation.AllocationReporter;
import com.oracle.truffle.api.interop.TruffleObject;
import com.oracle.truffle.api.nodes.NodeInfo;
import com.oracle.truffle.api.object.DynamicObject;
import com.oracle.truffle.api.object.Layout;
import com.oracle.truffle.api.object.Shape;
import com.oracle.truffle.api.source.Source;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Collections;
import java.util.List;

public class AbzuContext {
  private static final Source BUILTIN_SOURCE = Source.newBuilder(AbzuLanguage.ID, "", "abzu builtin").build();
  private static final Layout LAYOUT = Layout.createLayout();

  private final TruffleLanguage.Env env;
  private final BufferedReader input;
  private final PrintWriter output;
  private final AbzuFunctionRegistry functionRegistry;
  private final Shape emptyShape;
  private final AbzuLanguage language;
  private final AllocationReporter allocationReporter;
  private final Iterable<Scope> topScopes; // Cache the top scopes

  public AbzuContext(AbzuLanguage language, TruffleLanguage.Env env, List<NodeFactory<? extends AbzuBuiltinNode>> externalBuiltins) {
    this.env = env;
    this.input = new BufferedReader(new InputStreamReader(env.in()));
    this.output = new PrintWriter(env.out(), true);
    this.language = language;
    this.allocationReporter = env.lookup(AllocationReporter.class);
    this.functionRegistry = new AbzuFunctionRegistry(language);
    this.topScopes = Collections.singleton(Scope.newBuilder("global", functionRegistry.getFunctionsObject()).build());
    installBuiltins();
    for (NodeFactory<? extends AbzuBuiltinNode> builtin : externalBuiltins) {
      installBuiltin(builtin);
    }
    this.emptyShape = LAYOUT.createShape(AbzuObjectType.INSTANCE);
  }

  /**
   * Returns the default input, i.e., the source for the {@link AbzuReadlnBuiltin}. To allow unit
   * testing, we do not use {@link System#in} directly.
   */
  public BufferedReader getInput() {
    return input;
  }

  /**
   * The default default, i.e., the output for the {@link AbzuPrintlnBuiltin}. To allow unit
   * testing, we do not use {@link System#out} directly.
   */
  public PrintWriter getOutput() {
    return output;
  }

  /**
   * Returns the registry of all functions that are currently defined.
   */
  public AbzuFunctionRegistry getFunctionRegistry() {
    return functionRegistry;
  }

  public Iterable<Scope> getTopScopes() {
    return topScopes;
  }

  /**
   * Adds all builtin functions to the {@link AbzuFunctionRegistry}. This method lists all
   * {@link AbzuBuiltinNode builtin implementation classes}.
   */
  private void installBuiltins() {
//    installBuiltin(SLReadlnBuiltinFactory.getInstance());
//    installBuiltin(SLPrintlnBuiltinFactory.getInstance());
//    installBuiltin(SLNanoTimeBuiltinFactory.getInstance());
//    installBuiltin(SLDefineFunctionBuiltinFactory.getInstance());
//    installBuiltin(SLStackTraceBuiltinFactory.getInstance());
//    installBuiltin(SLHelloEqualsWorldBuiltinFactory.getInstance());
//    installBuiltin(SLNewObjectBuiltinFactory.getInstance());
//    installBuiltin(SLEvalBuiltinFactory.getInstance());
//    installBuiltin(SLImportBuiltinFactory.getInstance());
//    installBuiltin(SLGetSizeBuiltinFactory.getInstance());
//    installBuiltin(SLHasSizeBuiltinFactory.getInstance());
//    installBuiltin(SLIsExecutableBuiltinFactory.getInstance());
//    installBuiltin(SLIsNullBuiltinFactory.getInstance());
  }

  public void installBuiltin(NodeFactory<? extends AbzuBuiltinNode> factory) {
    /*
     * The builtin node factory is a class that is automatically generated by the Truffle DSL.
     * The signature returned by the factory reflects the signature of the @Specialization
     *
     * methods in the builtin classes.
     */
    int argumentCount = factory.getExecutionSignature().size();
    AbzuExpressionNode[] argumentNodes = new AbzuExpressionNode[argumentCount];
    /*
     * Builtin functions are like normal functions, i.e., the arguments are passed in as an
     * Object[] array encapsulated in SLArguments. A SLReadArgumentNode extracts a parameter
     * from this array.
     */
    for (int i = 0; i < argumentCount; i++) {
      argumentNodes[i] = new AbzuReadArgumentNode(i);
    }
    /* Instantiate the builtin node. This node performs the actual functionality. */
    AbzuBuiltinNode builtinBodyNode = factory.createNode((Object) argumentNodes);
    builtinBodyNode.addRootTag();
    /* The name of the builtin function is specified via an annotation on the node class. */
    String name = lookupNodeInfo(builtinBodyNode.getClass()).shortName();
    builtinBodyNode.setUnavailableSourceSection();

    /* Wrap the builtin in a RootNode. Truffle requires all AST to start with a RootNode. */
    AbzuRootNode rootNode = new AbzuRootNode(language, new FrameDescriptor(), builtinBodyNode, BUILTIN_SOURCE.createUnavailableSection(), name);

    /* Register the builtin function in our function registry. */
    getFunctionRegistry().register(name, Truffle.getRuntime().createCallTarget(rootNode));
  }

  public static NodeInfo lookupNodeInfo(Class<?> clazz) {
    if (clazz == null) {
      return null;
    }
    NodeInfo info = clazz.getAnnotation(NodeInfo.class);
    if (info != null) {
      return info;
    } else {
      return lookupNodeInfo(clazz.getSuperclass());
    }
  }

  /*
   * Methods for object creation / object property access.
   */

  public AllocationReporter getAllocationReporter() {
    return allocationReporter;
  }

  /**
   * Allocate an empty object. All new objects initially have no properties. Properties are added
   * when they are first stored, i.e., the store triggers a shape change of the object.
   */
  public DynamicObject createObject() {
    DynamicObject object = null;
    allocationReporter.onEnter(null, 0, AllocationReporter.SIZE_UNKNOWN);
    object = emptyShape.newInstance();
    allocationReporter.onReturnValue(object, 0, AllocationReporter.SIZE_UNKNOWN);
    return object;
  }

  public static boolean isAbzuObject(TruffleObject value) {
    /*
     * LAYOUT.getType() returns a concrete implementation class, i.e., a class that is more
     * precise than the base class DynamicObject. This makes the type check faster.
     */
    return LAYOUT.getType().isInstance(value) && LAYOUT.getType().cast(value).getShape().getObjectType() == AbzuObjectType.INSTANCE;
  }

  /*
   * Methods for language interoperability.
   */

  public static Object fromForeignValue(Object a) {
    if (a instanceof Long || a instanceof String || a instanceof Boolean) {
      return a;
    } else if (a instanceof Character) {
      return String.valueOf(a);
    } else if (a instanceof Number) {
      return fromForeignNumber(a);
    } else if (a instanceof TruffleObject) {
      return a;
    } else if (a instanceof AbzuContext) {
      return a;
    }
    CompilerDirectives.transferToInterpreter();
    throw new IllegalStateException(a + " is not a Truffle value");
  }

  @CompilerDirectives.TruffleBoundary
  private static long fromForeignNumber(Object a) {
    return ((Number) a).longValue();
  }

  public CallTarget parse(Source source) {
    return env.parse(source);
  }

  public TruffleObject getPolyglotBindings() {
    return (TruffleObject) env.getPolyglotBindings();
  }

  public static AbzuContext getCurrent() {
    return AbzuLanguage.getCurrentContext();
  }
}
